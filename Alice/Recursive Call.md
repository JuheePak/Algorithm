### 알고리즘 - Recursive Call(재귀 호출)

### `알고리즘이란?`

- **계산을 통하여 해결**할 수 있는 문제를 해결하는 방법
- 유한성, 명확성, 입/출력, 효과성 5가지 조건
  - 무한루프X
  - 0개 이상의 입력과 1개 이상의 출력이 존재



### `재귀호출이란?`

- 자기 자신을 호출하는 것
- n! = n * (n-1)! 
- Factorial(n): n!을 반환하는 함수

```python
def Factorial(n):
    if n == 0: #기저조건, base condition
        return 1 # 0! = 1 
    else:
        return n * Factorial(n-1)         
```



### `수학적 귀납법 = 재귀적 증명법`  -> 명제

### `재귀 호출 = 재귀적 계산법` -> 값

- 명제 P(n)을 다음과 같이 증명하는 방법
  - n = 1일때 성립함을 보인다.
  - P(k)가 성립한다고 **가정할 때**, P(k+1)이 성립함을 보인다.
  - 따라서 모든 자연수 n에 대하여 P(n)이 성립한다.

> e.g.) 모든 자연수 n에 대하여 n! <=n^n임을 증명하라.
>
> 1. n=1일때 성립한다.
> 2. k! <= k^k 가 성립한다고 가정할 때, p(k+1)이 성립함을 증명한다.
>
> - (k+1)! <= (k+1)^(k+1)는, (k+1)*(k)^k <= ((k+1)^k)\*k 와 같으므로 성립한다.
> - 단, 우리는 p(k)가 성립한다고 **가정하였을 뿐** 성립하는지는 아직 모른다.
> - 수학적 귀납법에 따라 **모든 자연수 n에 대하여 명제가 성립**한다.



### ` 재귀적 계산 방법`

- Factorial(n): n!을 반환하는 함수
- Factorial(n) = Factorial(n-1)*n
- n=1일때는 Factorial(n)이 정상 작동한다.
  - 그렇다면 n=6일 때 정상 작동하나?
  - 아니, n=5일때 확인하면 돼
  - 아니, n=4일때 확인하면 돼
  - 아니, n=3일때 확인하면 돼
  - 아니, n=2일때 확인하면 돼
  - 아니, n=1일때 확인하면 돼
  - n=1일때 되니까, n=2일때 확인해봐 ----> 다시 올라간다.



### `퀵정렬(Quick Sort)`

- 재귀호출을 이용한 대표적인 정렬
- 원소가 0, 1개는 정렬된 데이터 --> base condition

``` python
def quickSort(data):
    if len(data) <= 1:
        return data
pivot = data[0]

left = getSmallNumbers(data, pivot)
right = getLargeNumbers(data, pivot)

return quickSort(left) + [pivot] + quickSort(right)
```



### `재귀함수 디자인`

- 재귀함수를 디자인하기 위한 세가지 단계

1. 함수의 정의를 명확히 한다. -> **명확한 명제**
2. **기저조건(Base condition)**에서 함수가 제대로 동작하게 작성한다. 0! = 1
3. 함수가 **작은 input**에 대하여 제대로 동작한다고 가정하고 함수를 완성한다.